#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <poll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>  // For general socket utils (future-proof)
#include <unistd.h>
#include <vector>
#include <chrono>
#include <thread>
#include <queue>  // For pending_fds

extern "C" {
#include <lsquic.h>
#include <lsquic_types.h>
}

#define MAX_POLL_FDS 1024
#define IDLE_TIMEOUT_US 10000000  // 10 seconds for idle conn
#define PROXY_IDLE_TIMEOUT_SEC 10  // Robust timeout for proxy pairs

// Custom ALPN for tunnel
static const char *alpn = "r-tunnel";

// Forward declaration for send_packets_out (used before definition)
static int send_packets_out(void *ctx, const lsquic_out_spec *specs, unsigned n_specs);

// ProxyPair structure for tunneling
struct ProxyPair {
    lsquic_stream_t *stream;
    int tcp_fd;
    std::vector<char> to_stream_buf;  // Buffer from TCP to stream
    std::vector<char> to_tcp_buf;     // Buffer from stream to TCP
    std::chrono::steady_clock::time_point last_activity;
    bool closed = false;
};

// Global variables
lsquic_engine_t *engine;
int quic_udp_fd;
int tcp_listen_fd;
lsquic_conn_t *tunnel_conn = nullptr;
std::map<int, ProxyPair *> fd_to_proxy;  // TCP fd to ProxyPair
std::map<lsquic_stream_t *, ProxyPair *> stream_to_proxy;
std::queue<int> pending_fds;  // Queue for pending TCP fds (for server-initiated streams)

// Callbacks
static lsquic_conn_ctx_t *server_on_new_conn(void *stream_if_ctx, lsquic_conn_t *conn) {
    (void)stream_if_ctx;
    // ALPN check removed: No public lsquic_conn_get_alpn(); assume tunnel (single-conn proxy).
    // If needed: Use ea_get_ssl_ctx to set per-ALPN SSL_CTX; access via internal lsquic_conn_get_ssl (not public).
    tunnel_conn = conn;
    std::cout << "Tunnel connection established" << std::endl;
    return (lsquic_conn_ctx_t *)conn;  // Simple ctx
}

static void server_on_conn_closed(lsquic_conn_t *conn) {
    if (conn == tunnel_conn) {
        tunnel_conn = nullptr;
        std::cout << "Tunnel connection closed" << std::endl;
        // Close all proxies
        for (auto &p : fd_to_proxy) {
            close(p.first);
        }
        fd_to_proxy.clear();
        stream_to_proxy.clear();
        // Drain pending fds
        while (!pending_fds.empty()) {
            close(pending_fds.front());
            pending_fds.pop();
        }
    }
}

static lsquic_stream_ctx_t *server_on_new_stream(void *stream_if_ctx, lsquic_stream_t *stream) {
    (void)stream_if_ctx;
    if (pending_fds.empty()) {
        return nullptr;  // No pending TCP (client-initiated? Ignore for proxy)
    }
    int fd = pending_fds.front();
    pending_fds.pop();
    ProxyPair *pair = new ProxyPair{stream, fd, {}, {}, std::chrono::steady_clock::now()};
    fd_to_proxy[fd] = pair;
    stream_to_proxy[stream] = pair;
    lsquic_stream_wantread(stream, 1);
    lsquic_stream_wantwrite(stream, 0);  // Start with read
    return (lsquic_stream_ctx_t *)pair;  // Return ctx for LSQUIC
}

static void server_on_read(lsquic_stream_t *stream, lsquic_stream_ctx_t *ctx) {
    (void)ctx;
    ProxyPair *pair = stream_to_proxy[stream];
    if (!pair || pair->closed) return;

    char buf[4096];
    ssize_t n = lsquic_stream_read(stream, buf, sizeof(buf));
    if (n > 0) {
        pair->last_activity = std::chrono::steady_clock::now();
        // Write to TCP fd (non-blocking)
        ssize_t written = write(pair->tcp_fd, buf, n);
        if (written < n) {
            // Buffer the rest if partial write
            pair->to_tcp_buf.insert(pair->to_tcp_buf.end(), buf + written, buf + n);
        }
        lsquic_stream_wantread(stream, (n == sizeof(buf)) ? 1 : 0);  // More data?
    } else if (n == 0) {
        pair->closed = true;
        lsquic_stream_shutdown(stream, 0);  // Shutdown read
    } else if (n < 0) {
        // Error: e.g., ECONNRESET
        pair->closed = true;
        lsquic_stream_close(stream);
    }
}

static void server_on_write(lsquic_stream_t *stream, lsquic_stream_ctx_t *ctx) {
    (void)ctx;
    ProxyPair *pair = stream_to_proxy[stream];
    if (!pair || pair->closed) return;

    // Write buffered data if any
    if (!pair->to_stream_buf.empty()) {
        ssize_t written = lsquic_stream_write(stream, pair->to_stream_buf.data(), pair->to_stream_buf.size());
        if (written > 0) {
            pair->last_activity = std::chrono::steady_clock::now();
            pair->to_stream_buf.erase(pair->to_stream_buf.begin(), pair->to_stream_buf.begin() + written);
        }
        if (written < 0) {
            // Error: e.g., flow control
            pair->closed = true;
            lsquic_stream_close(stream);
        }
    }
    lsquic_stream_wantwrite(stream, pair->to_stream_buf.empty() ? 0 : 1);
}

static void server_on_close(lsquic_stream_t *stream, lsquic_stream_ctx_t *ctx) {
    (void)ctx;
    ProxyPair *pair = stream_to_proxy[stream];
    if (pair) {
        if (!pair->closed) {
            close(pair->tcp_fd);
        }
        fd_to_proxy.erase(pair->tcp_fd);
        stream_to_proxy.erase(stream);
        delete pair;
    }
}

static const lsquic_stream_if stream_callbacks = {
    .on_new_conn               = server_on_new_conn,     // Mandatory
    .on_goaway_received        = NULL,                   // Optional
    .on_conn_closed            = server_on_conn_closed,  // Mandatory
    .on_new_stream             = server_on_new_stream,   // Mandatory
    .on_read                   = server_on_read,         // Mandatory
    .on_write                  = server_on_write,        // Mandatory
    .on_close                  = server_on_close,        // Mandatory
    .on_dg_write               = NULL,                   // Optional (datagrams)
    .on_datagram               = NULL,                   // Optional (datagrams)
    .on_hsk_done               = NULL,                   // Optional
    .on_new_token              = NULL,                   // Optional
    .on_sess_resume_info       = NULL,                   // Optional (deprecated)
    .on_reset                  = NULL,                   // Optional
    .on_conncloseframe_received= NULL,                   // Optional
};

static int send_packets_out(void *ctx, const lsquic_out_spec *specs, unsigned n_specs) {
    int sockfd = (int)(uintptr_t)ctx;
    unsigned n_sent = 0;
    for (unsigned i = 0; i < n_specs; ++i) {
        struct msghdr msg = {};
        msg.msg_name = (void *)specs[i].dest_sa;
        msg.msg_namelen = sizeof(struct sockaddr_in);  // Assume IPv4
        msg.msg_iov = specs[i].iov;
        msg.msg_iovlen = specs[i].iovlen;
        if (sendmsg(sockfd, &msg, 0) < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) return n_sent;
            return -1;
        }
        ++n_sent;
    }
    return n_sent;
}

// Create sockets
int create_udp_socket(uint16_t port) {
    int s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) return -1;
    struct sockaddr_in sa = {};
    sa.sin_family = AF_INET;
    sa.sin_port = htons(port);
    sa.sin_addr.s_addr = INADDR_ANY;
    if (bind(s, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
        close(s);
        return -1;
    }
    return s;
}

int create_tcp_listener(uint16_t port) {
    int s = socket(AF_INET, SOCK_STREAM, 0);
    if (s < 0) return -1;
    int opt = 1;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    struct sockaddr_in sa = {};
    sa.sin_family = AF_INET;
    sa.sin_port = htons(port);
    sa.sin_addr.s_addr = INADDR_ANY;
    if (bind(s, (struct sockaddr *)&sa, sizeof(sa)) < 0 || listen(s, 128) < 0) {
        close(s);
        return -1;
    }
    return s;
}

// Main
int main(int argc, char **argv) {
    (void)argc;
    (void)argv;
    if (lsquic_global_init(LSQUIC_GLOBAL_SERVER) != 0) {
        std::cerr << "LSQUIC init failed" << std::endl;
        return EXIT_FAILURE;
    }

    lsquic_engine_settings es = {};
    lsquic_engine_init_settings(&es, LSENG_SERVER);
    es.es_idle_conn_to = IDLE_TIMEOUT_US;  // Robust idle timeout

    lsquic_engine_api engine_api = {};
    engine_api.ea_settings = &es;
    engine_api.ea_stream_if = &stream_callbacks;
    engine_api.ea_packets_out = send_packets_out;
    engine_api.ea_alpn = alpn;
    engine_api.ea_packets_out_ctx = nullptr;  // Set later

    quic_udp_fd = create_udp_socket(4433);  // QUIC port
    if (quic_udp_fd < 0) {
      std::cerr << "LSQUIC create_udp_socket failed" << std::endl;
      return EXIT_FAILURE;
    }
    engine_api.ea_packets_out_ctx = (void *)(uintptr_t)quic_udp_fd;

    engine = lsquic_engine_new(LSENG_SERVER, &engine_api);
    if (!engine) {
      std::cerr << "LSQUIC engine new failed" << std::endl;
      return EXIT_FAILURE;
    }

    tcp_listen_fd = create_tcp_listener(8080);  // TCP proxy port
    if (tcp_listen_fd < 0) {
      std::cerr << "create_tcp_listener failed" << std::endl;
      return EXIT_FAILURE;
    }
    std::cout << "Listening on TCP port 8080..." << std::endl;

    struct sockaddr_in local_sa = {};  // Fill with actual local addr if needed

    std::vector<struct pollfd> pollfds;
    pollfds.push_back({quic_udp_fd, POLLIN, 0});
    pollfds.push_back({tcp_listen_fd, POLLIN, 0});

    while (true) {
        int timeout_ms = -1;
        int diff;
        if (lsquic_engine_earliest_adv_tick(engine, &diff)) {
            timeout_ms = (diff > 0) ? diff / 1000 : 0;
        }

        // Add pollfds for active TCP fds
        pollfds.resize(2 + fd_to_proxy.size());
        size_t idx = 2;
        for (auto &p : fd_to_proxy) {
            short events = POLLIN;
            if (!p.second->to_tcp_buf.empty()) events |= POLLOUT;
            pollfds[idx++] = {p.first, events, 0};
        }

        poll(pollfds.data(), pollfds.size(), timeout_ms);  // Unused ret; can add error check if needed
        if (timeout_ms == 0) {
            lsquic_engine_process_conns(engine);
            continue;
        }

        if (pollfds[0].revents & POLLIN) {
            char buf[0x1000];
            struct sockaddr_in peer_sa;
            socklen_t len = sizeof(peer_sa);
            ssize_t n = recvfrom(quic_udp_fd, buf, sizeof(buf), 0, (struct sockaddr *)&peer_sa, &len);
            if (n > 0) {
                lsquic_engine_packet_in(engine, (unsigned char *)buf, n, (struct sockaddr *)&local_sa, (struct sockaddr *)&peer_sa, (void *)(uintptr_t)quic_udp_fd, 0);
            }
        }

        if (pollfds[1].revents & POLLIN) {
            struct sockaddr_in client_sa;
            socklen_t len = sizeof(client_sa);
            int new_fd = accept(tcp_listen_fd, (struct sockaddr *)&client_sa, &len);
            if (new_fd >= 0) {
                if (tunnel_conn) {
                    pending_fds.push(new_fd);
                    lsquic_conn_make_stream(tunnel_conn);  // Triggers on_new_stream (void return)
                } else {
                    close(new_fd);
                }
            }
        }

        // Handle proxy TCP fds
        idx = 2;
        auto now = std::chrono::steady_clock::now();
        for (auto it = fd_to_proxy.begin(); it != fd_to_proxy.end(); ) {
            struct pollfd &pfd = pollfds[idx++];
            if (pfd.revents & POLLIN) {
                char buf[4096];
                ssize_t n = read(pfd.fd, buf, sizeof(buf));
                if (n > 0) {
                    ProxyPair *pair = it->second;
                    pair->last_activity = now;
                    pair->to_stream_buf.insert(pair->to_stream_buf.end(), buf, buf + n);
                    lsquic_stream_wantwrite(pair->stream, 1);
                } else if (n == 0) {
                    ProxyPair *pair = it->second;
                    pair->closed = true;
                    lsquic_stream_shutdown(pair->stream, 1);  // Shutdown write
                    ++it;
                    continue;
                } else {
                    // Read error
                    it->second->closed = true;
                    lsquic_stream_close(it->second->stream);
                }
            }
            if (pfd.revents & POLLOUT) {
                ProxyPair *pair = it->second;
                if (!pair->to_tcp_buf.empty()) {
                    ssize_t written = write(pfd.fd, pair->to_tcp_buf.data(), pair->to_tcp_buf.size());
                    if (written > 0) {
                        pair->last_activity = now;
                        pair->to_tcp_buf.erase(pair->to_tcp_buf.begin(), pair->to_tcp_buf.begin() + written);
                    }
                }
            }
            // Timeout check
            ProxyPair *pair = it->second;
            if (std::chrono::duration_cast<std::chrono::seconds>(now - pair->last_activity).count() > PROXY_IDLE_TIMEOUT_SEC) {
                pair->closed = true;
                lsquic_stream_close(pair->stream);
                ++it;
                continue;
            }
            ++it;
        }

        lsquic_engine_process_conns(engine);
    }

    lsquic_engine_destroy(engine);
    lsquic_global_cleanup();
    return EXIT_SUCCESS;
}
